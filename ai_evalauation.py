# -*- coding: utf-8 -*-
"""Ai_Evalauation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fUV314wSehI6gDPbdAkcCLZU8LgPj_Tq

Practical -1 ChatBot
"""

from datetime import datetime
import random

def filter_question(Q):
  space = False
  x = ""
  for q in Q:
    if q.isalpha():
      x += q
      space = False
    if q == " ":
      if not space :
        x += q
        space = True
  if x == "":
    return None
  return x

def find_key(Q, keys):
  for key in keys:
    if Q == key: 
      return key
  return None
  

qa = {
  "how are you" : ["I'm fine", "So far, so good!"],
  "what time it is" : [str(datetime.now().strftime("%H:%M:%S")), str(datetime.now().strftime("%H:%M")), str(datetime.now().strftime("%I:%M %p "))],
  "what date is today" : [str(datetime.now().strftime("%d/%m/%Y")),str(datetime.now().strftime("%d-%m-%Y")) ,],
  "which month it is running" : [str(datetime.now().strftime("%B")), str(datetime.now().strftime("%b"))],
  "which year it is running" : [str(datetime.now().strftime("%Y")),str(datetime.now().strftime("%y")),],
  "who created you" : ["Heet Mavani Pote Hoooo"],
  "who is Heet" : ["He is a student at U.V. Patel College of engineering.", "He's the guy who created me.", ],
  "what is your name" : ["Nia", "Sia", "Jia", "Tia"],
  "which color do you like" : ["red", "pink", "blue"],
  "which car do you like" : ["TATA Nexon", "TATA Harrier", "Jaguar XF", "BMW X5", "Lamborghini Huracan", "Range Rover", "Audi A6"],
  "Who is founder of google" : ["Larry Page", "Sergey Brin"],
  "Who is founder of amazon" : ["Jeff Bezos"],
  "Who is founder of reliance" : ["Dhirubhai Ambani"],
  
}

keys = list(qa.keys())
run = True
while run:
  st = input("\nTo start chatbot, Write 'HI'.\n:")
  if "hi" in st.lower():
    while True:
      q = input("\nQ: ").lower()
      if q:
        if q == 'exit' :
          run = False
          break
        q = q.strip()
      q = filter_question(q)
      if q:
        q = q.strip()
        
        # print("filtered: ", q)
        k = find_key(q, keys)
        # print("Key: ", k)
        if k :
          ans = qa[k]
          print(f"A: {random.choice(ans)}")
        else:
          print("I can't answer your question please try another.")

      else:
          print("I can't answer your question please try another.")

"""Practical -2

"""

class Node:
    def __init__(self, x, y):
        self.x, self.y = x, y

    def __str__(self) -> str:
        return f"({self.x}, {self.y})"


def operation(node, ruleNo):
    global maxCapacity
    # if not node:
    #     return None

    x, y = node.x, node.y

    # Rule-1: Fill X gal jug
    if ruleNo == 1:
        if x < maxCapacity.x:
            x = maxCapacity.x
        else:
            return None

    # Rule-2: Fill Y gal jug
    elif ruleNo == 2:
        if y < maxCapacity.y:
            y = maxCapacity.y
        else:
            return None

    # Rule-3: Empty X gal jug on ground
    elif ruleNo == 3:
        if x > 0:
            x = 0
        else:
            return None

    # Rule-4: Empty Y gal jug on ground
    elif ruleNo == 4:
        if y > 0:
            y = 0
        else:
            return None

    # Rule-5: Pour water form Y gal jug to fill X gal jug
    elif ruleNo == 5:
        total = x + y
        if (0 < total) and (total >= maxCapacity.x) and (y > 0):
            x, y = maxCapacity.x, y - (maxCapacity.x - x)

        else:
            return None

    # Rule-6: Pour water from X gal jug to fill Y gal jug
    elif ruleNo == 6:
        total = x + y
        if (0 < total) and (total >= maxCapacity.y) and (x > 0):
            x, y = x - (maxCapacity.y - y), maxCapacity.y
        else:
            return None

    # Rule-7: Pour all water form Y gal jug into X gal jug
    elif ruleNo == 7:
        total = x + y
        if (0 < total) and (total <= maxCapacity.x) and (y >= 0):
            x, y = total, 0
        else:
            return None

    # Rule-8: Pour all water form X gal jug into Y gal jug
    elif ruleNo == 8:
        total = x + y
        if (0 < total) and (total <= maxCapacity.y) and (x >= 0):
            x, y = 0, total
        else:
            return None

    if (node.x == x) and (node.y == y):
        return None

    return Node(x, y)


# Initial state
currNode = Node(0, 0)

# Max capacity
mx = [int(x) for x in input("Enter max capacity of Jug-1 and Jug-2: ").split()]
maxCapacity = Node(mx[0], mx[1])

# Goal state
goal = int(input("Enter value of Goal in Jug-1: "))

while True:
    r = int(input("Enter rule No.: "))
    newNode = operation(currNode, r)
    if not newNode:
        print("-----Rule can't apply, please choose another-----")
        print(currNode)
        continue
    else:
        currNode = newNode
        if currNode.x == goal:
            print(f"Got the solution: ({currNode.x}, {currNode.y})")
            break
        else:
            print(f": ({currNode.x}, {currNode.y})")

"""Practical-3 Water Jug Problem using BFS/DFS"""

import time
import random
import enum

class DfsMode(enum.Enum):
    ALL_SUCCESSORS = 0
    ALL_RANDOM_SUCCESSORS = 1
    ALL_RANDOM_SUCCESSORS_WITH_OPTIMIZATION = 2
    

class Node:
    def __init__(self, x, y, parent) :
        self.x, self.y = x, y
        self.parent = parent
        
    def __str__(self) -> str:
        return f"({self.x}, {self.y})"
    
    def __eq__(self, __o: object) -> bool:
        if (self.x == __o.x) and (self.y == __o.y):
            return True
        else:
            return False
        
    def path(self) -> str :
        currNode = self
        path = []
        while currNode.parent:
            path.append(currNode.parent)
            currNode = currNode.parent
        return path

class BFS:
    def __init__(self) -> None:
        self.queue = list()
        
        
    def operation(self, node, ruleNo):
        # global maxCapacity
        
        x, y = node.x, node.y
        
        # Rule-1: Fill X gal jug
        if ruleNo == 1:
            if x < maxCapacity.x :
                x = maxCapacity.x
            else:
                return None
        
        # Rule-2: Fill Y gal jug
        elif ruleNo == 2:
            if y < maxCapacity.y :
                y = maxCapacity.y
            else:
                return None
            
        # Rule-3: Empty X gal jug on ground
        elif ruleNo == 3:
            if x > 0:
                x = 0
            else:
                return None
            
        # Rule-4: Empty Y gal jug on ground
        elif ruleNo == 4:
            if y > 0:
                y = 0
            else:
                return None
        
        # Rule-5: Pour water form Y gal jug to fill X gal jug
        elif ruleNo == 5:
            total = x + y
            if (0 < total) and (total >= maxCapacity.x) and (y > 0):
                x, y = maxCapacity.x, y - ( maxCapacity.x - x)
                
            else:
                return None
        
        # Rule-6: Pour water from X gal jug to fill Y gal jug
        elif ruleNo == 6:
            total = x + y
            if (0 < total) and (total >= maxCapacity.y) and (x > 0):
                x, y = x - (maxCapacity.y - y), maxCapacity.y
            else:
                return None
        
        # Rule-7: Pour all water form Y gal jug into X gal jug
        elif ruleNo == 7:
            total = x + y
            if (0 < total) and (total <= maxCapacity.x) and (y >= 0):
                x, y = total, 0
            else:
                return None
            
        # Rule-8: Pour all water form X gal jug into Y gal jug
        elif ruleNo == 8:
            total = x + y
            if (0 < total) and (total <= maxCapacity.y) and (x >= 0):
                x, y = 0, total
            else:
                return None
            
        if (node.x == x) and (node.y == y):
            return None
        
        return Node(x, y, node)
    
    def generateAllSuccessor(self, node):
        successors = list()
        
        rules = [x for x in range(1,9)] 
        # random.shuffle(rules)
        # print(f"Successors of: {node}")
        for i in rules:
            res = self.operation(node, i)
            if res:
                successors.append(res)
                # print(f"{i}: {res}")

        return successors

    def solveWaterJug(self, initNode, goal):
        start_time = time.time()
        
        self.queue.append(initNode)

        while self.queue:
            node = self.queue.pop(0)
            # print(node)
            if node.x == goal:
                print("Reached goal: ",node)
                path = node.path()
                exec_time = time.time() - start_time
                
                path.reverse()
                path.append(node)
                cost = len(path)
                path = "-> ".join([str(p) for p in path])
                return path, cost, exec_time
            
            else:
                successors = self.generateAllSuccessor(node)
                self.queue.extend(successors)
      
class DFS:
    def __init__(self) -> None:
        
        self.visited = list()
        self.stack = list()
        self.visitedQueue = list()
        
    def operation(self, node, ruleNo):
        # global maxCapacity
        
        x, y = node.x, node.y
        
        # Rule-1: Fill X gal jug
        if ruleNo == 1:
            if x < maxCapacity.x :
                x = maxCapacity.x
            else:
                return None
        
        # Rule-2: Fill Y gal jug
        elif ruleNo == 2:
            if y < maxCapacity.y :
                y = maxCapacity.y
            else:
                return None
            
        # Rule-3: Empty X gal jug on ground
        elif ruleNo == 3:
            if x > 0:
                x = 0
            else:
                return None
            
        # Rule-4: Empty Y gal jug on ground
        elif ruleNo == 4:
            if y > 0:
                y = 0
            else:
                return None
        
        # Rule-5: Pour water form Y gal jug to fill X gal jug
        elif ruleNo == 5:
            total = x + y
            if (0 < total) and (total >= maxCapacity.x) and (y > 0):
                x, y = maxCapacity.x, y - ( maxCapacity.x - x)
                
            else:
                return None
        
        # Rule-6: Pour water from X gal jug to fill Y gal jug
        elif ruleNo == 6:
            total = x + y
            if (0 < total) and (total >= maxCapacity.y) and (x > 0):
                x, y = x - (maxCapacity.y - y), maxCapacity.y
            else:
                return None
        
        # Rule-7: Pour all water form Y gal jug into X gal jug
        elif ruleNo == 7:
            total = x + y
            if (0 < total) and (total <= maxCapacity.x) and (y >= 0):
                x, y = total, 0
            else:
                return None
            
        # Rule-8: Pour all water form X gal jug into Y gal jug
        elif ruleNo == 8:
            total = x + y
            if (0 < total) and (total <= maxCapacity.y) and (x >= 0):
                x, y = 0, total
            else:
                return None
            
        if (node.x == x) and (node.y == y):
            return None
        
        return Node(x, y, node)

    def generateAllSuccessor(self, node):
        global dfs_all_start_time
        successors = list()
        rules = range(1,9)
        for i in rules:
            if time.time()- dfs_all_start_time >= 5 :
                return None
            
            res = self.operation(node, i)
            if res:
                successors.append(res)

        return successors

    def generateAllRandomSuccessor(self, node):
        successors = list()
        
        rules = [x for x in range(1,9)] 
        random.shuffle(rules)
        
        for i in rules:
            res = self.operation(node, i)
            if res:
                successors.append(res)

        return successors

    def generateAllRandomVisitedSuccessor(self, node):
        successors = list()
        
        rules = [x for x in range(1,9)] 
        random.shuffle(rules)
        
        for i in rules:
            res = self.operation(node, i)
            if res:
                if res not in self.visitedQueue:
                    self.visitedQueue.append(res)
                    successors.append(res)

        return successors

    def solveWaterJug(self, initNode, goal, mode):
        start_time = time.time()
        
        self.stack.append(initNode)

        while self.stack:
            node = self.stack.pop()
            if node.x == goal:
                # print("Reached goal: ",node)
                path = node.path()
                exec_time = time.time() - start_time
                
                path.reverse()
                path.append(node)
                cost = len(path)
                path = "-> ".join([str(p) for p in path])
                return path, cost, exec_time
            
            else:
                if mode == DfsMode.ALL_SUCCESSORS:
                    successors = self.generateAllSuccessor(node)
                    if successors :
                        self.stack.extend(successors)
                    else :
                        return "No path found", "Infinite", "Infinite"
                        
                elif mode == DfsMode.ALL_RANDOM_SUCCESSORS:
                    successors = self.generateAllRandomSuccessor(node)
                    if successors :
                        self.stack.extend(successors)
                        
                elif mode == DfsMode.ALL_RANDOM_SUCCESSORS_WITH_OPTIMIZATION:
                    successors = self.generateAllRandomVisitedSuccessor(node)
                    if successors :
                        self.stack.extend(successors)
        
        
               
      
      
# Max capacity
mx = [int(x) for x in input("Enter max capacity of Jug-1 and Jug-2: ").split()]
maxCapacity = Node(mx[0], mx[1], None)

# Goal state
goal = int(input("Enter value of Goal in Jug-1: "))

# Initial state
initNode = Node(0,0, None)

bfs = BFS()
path, cost, exec_time = bfs.solveWaterJug(initNode, goal)

print("\n\n----------------------------------------Using BFS---------------------------------------------")
print(f"Path: {path}\nPath cost: {cost}")
print(f"Execution time: {exec_time} s")

dfs = DFS()
print("\n\n----------------------------------------Using DFS---------------------------------------------")

print("--------------------Generating all successors-------------------------")
dfs_all_start_time = time.time()
path, cost, exec_time = dfs.solveWaterJug(initNode, goal, DfsMode.ALL_SUCCESSORS)
print("Loop gone infinite")

print("\n\n--------------------Generating all random successors-------------------------")
path, cost, exec_time = dfs.solveWaterJug(initNode, goal, DfsMode.ALL_RANDOM_SUCCESSORS)
print(f"Path: {path}\nPath cost: {cost}")
print(f"Execution time: {exec_time} s")


print("\n\n--------------------Generating all random successors with optimization-------------------------")
path, cost, exec_time = dfs.solveWaterJug(initNode, goal, DfsMode.ALL_RANDOM_SUCCESSORS_WITH_OPTIMIZATION)
print(f"Path: {path}\nPath cost: {cost}")
print(f"Execution time: {exec_time} s")

"""Practical-4 / 8 - puzzle using best first search algorithm

"""

print("Practical-4")

import enum
import random
import time

class Action(enum.Enum):
    MoveLeft = 1
    MoveRight = 2
    MoveUp = 3
    MoveDown = 4
    NoAction = 0

initPosition = [int(x) for x in input("Initstate: ").split()]
goalPosition = [int(x) for x in input("Goalstate: ").split()]

    
with open("result.txt", "w") as f :
        
    class Node:
        def __init__(self, position = [], parent = None, action = Action.NoAction) -> None:
            global goalPosition
            self.parent = parent
            
            if parent:
                # self.h = self.computeHuristic(bfs.goalNode.position)
                self.position = parent.position.copy()
                # self.move(action = action)
            else:
                self.position = position
                self.h = 0
            # self.h = self.computeHuristic()
            self.action = action
        
        def move(self, action):
            def swap(pos, i, j) :
                pos[i + j], pos[i] =  pos[i],  pos[i + j]
                
            xPos = self.position.index(0)
            
            if action == Action.MoveLeft:
                if xPos in [0,3,6] :
                    return False
                else:
                    swap(self.position, xPos, -1)
                    return True
                    
            elif action == Action.MoveRight:
                if xPos in [2, 5, 8]:
                    return False
                else:
                    swap(self.position, xPos, 1)
                    return True
                
            elif action == Action.MoveUp:
                if xPos in [0, 1, 2]:
                    return False
                else:
                    swap(self.position, xPos, -3)
                    return True
                
            elif action == Action.MoveDown:
                if xPos in [6, 7, 8]:
                    return False
                else:
                    swap(self.position, xPos, 3)
                    return True
        
        def __repr__(self) -> str:
            n = 3
            board_list = [self.position[i:i + n] for i in range(0, len(self.position), n)]
            board = ""
            if self.action == Action.MoveLeft:
                board += "Action.MoveLeft"
                
            elif self.action == Action.MoveUp:
                board += "Action.MoveUp"
                
            elif self.action == Action.MoveRight:
                board += "Action.MoveRight"
            
            elif self.action == Action.MoveDown:
                board += "Action.MoveDown"
                
            else:
                board += "Action.NoAction"
            
            board += f"[ {self.h} ]\n"
            
            board2 = ""
            for row in board_list:
                for col in  row:
                    board2 += f"{col} "
                board2 += "\n"
            board2 = board2.replace("0", "_")
                
            return board + board2
        
        def __eq__(self, __o: object) -> bool:
            return self.position == __o.position
        
        def __lt__(self, __o) -> bool:
            return self.h < __o.h
        
        def __cmp__(self, __o) -> bool:
            return self.h < __o.h
        
        def computeHuristic(self):
            global goalPosition
            lst = [0 if self.position[i] == goalPosition[i] else 1 for i in range(9)]
            x =  sum(lst)
            
            self.h = x
        
        def generateAllSuccessors(self):
            actions = [Action.MoveLeft, Action.MoveRight, Action.MoveUp, Action.MoveDown]
            random.shuffle(actions)
            random.shuffle(actions)
            
            successors = []
            for action in actions:
                node = Node(parent = self, action = action)
                isValidNode = node.move(action)
                
                if isValidNode :
                    node.computeHuristic()
                    successors.append(node)
            # for s in successors:
                # print(s)
                # f.write(str(s) + "\n")
                
            return successors

        def getPath(self):
            currNode = self
            path = []
            while currNode.parent:
                path.append(currNode)
                currNode = currNode.parent
            path.append(currNode)
            
            return path
        
    initNode = Node(position = initPosition)
    goalNode = Node(position = goalPosition)

    class BestFirstSearch:
        def __init__(self) -> None:
            self.OPEN = []
            self.CLOSED = []
        
        def popNode(self):
            self.OPEN.sort()
            return self.OPEN.pop(0)
        
        def solveEightPuzzle(self):
            global initNode
            
            self.OPEN.append(initNode)
            
            while self.OPEN:
                node = self.popNode()
               
                if node == goalNode:
                    print("Reached to goal")
                    f.write("Reached to goal\n")
                    
                    path = node.getPath()
                    path.reverse()
                    # path.append(node)
                    cost = len(path)
                    path = "\n\n".join([str(p) for p in path])
                    return path, cost, node
                
                self.CLOSED.append(node)

                successors = node.generateAllSuccessors()
                
                # print("\nSuccessors of :\n")
                # print(node)
                # print("___")
                # f.write("\nSuccessors of :\n")
                # f.write(str(node))
                # f.write("\n__\n")
                # print("___")
                # f.write("____\n")
                
                if successors:
                    for s in successors:
                        if s not in self.OPEN:
                            if s in self.CLOSED :
                                i = self.CLOSED.index(s)
                                # If heuristic value of s > the heruistic value of the node in CLOSED list
                                # Add s to closed list
                                if s.h > self.CLOSED[i].h:
                                    self.CLOSED.append(s)
                                # else:
                                #     self.OPEN.append(s)
                            else:
                                self.OPEN.append(s)
                        
            return None, None, None
    
    print("\nInitstate: ")
    f.write("\nInitstate: \n")
    print(initNode)
    f.write(str(initNode))
    
    print("\nGoalstate: ")
    f.write("\nGoalstate: \n")
    print(goalNode)
    f.write(str(goalNode))

    bfs = BestFirstSearch() 
    
    start_time = time.time()
    path, cost, finalNode = bfs.solveEightPuzzle()
    exec_time = time.time() - start_time
    
    
    
    if finalNode:
        
        # print("Final node:\n")
        # print(finalNode)
        print(":Path\n",path)
        f.write(":Path\n")
        f.write(path)
        print("Steps to goal: ", cost)
        f.write("\nSteps to goal: \n")
        f.write(str(cost))
        
    else:
        print("Unable to find solution.")
        f.write("Unable to find solution.")
    print(f"Execution TIme: {exec_time}")
    f.write(f"\nExecution TIme: {exec_time}")

"""Practical-5 8*Puzzle with A* star algorithm

*   # // A* (star) Pathfinding
# // Initialize both open and closed list
# let the openList equal empty list of nodes
# let the closedList equal empty list of nodes
# // Add the start node
# put the startNode on the openList (leave it's f at zero)
# // Loop until you find the end
# while the openList is not empty
#     // Get the current node
#     let the currentNode equal the node with the least f value
#     remove the currentNode from the openList
#     add the currentNode to the closedList
#     // Found the goal
#     if currentNode is the goal
#         Congratz! You've found the end! Backtrack to get path
#     // Generate children
#     let the children of the currentNode equal the adjacent nodes
    
#     for each child in the children
#         // Child is on the closedList
#         if child is in the closedList
#             continue to beginning of for loop
#         // Create the f, g, and h values
#         child.g = currentNode.g + distance between child and current
#         child.h = distance from child to end
#         child.f = child.g + child.h
#         // Child is already in openList
#         if child.position is in the openList's nodes positions
#             if the child.g is higher than the openList node's g
#                 continue to beginning of for loop
#         // Add the child to the openList
#         add the child to the openList
*   List item



"""

import enum
from mimetypes import init
import random

class Action(enum.Enum):
    MoveLeft = 1
    MoveRight = 2
    MoveUp = 3
    MoveDown = 4
    NoAction = 0

initPosition = [int(x) for x in input("Initstate: ").split()]
goalPosition = [int(x) for x in input("Goalstate: ").split()]

    
with open("result.txt", "w") as f :
        
    class Node:
        def __init__(self, position = [], parent = None, action = Action.NoAction) -> None:
            global goalPosition
            self.parent = parent
            
            if parent:
                # self.h = self.computeHuristic(bfs.goalNode.position)
                self.position = parent.position.copy()
                # self.move(action = action)
            else:
                self.position = position
                self.h = 0
                self.g = 0
                self.f = 0
            # self.h = self.computeHuristic()
            self.action = action
        
        def move(self, action):
            def swap(pos, i, j) :
                pos[i + j], pos[i] =  pos[i],  pos[i + j]
                
            xPos = self.position.index(0)
            
            if action == Action.MoveLeft:
                if xPos in [0,3,6] :
                    return False
                else:
                    swap(self.position, xPos, -1)
                    return True
                    
            elif action == Action.MoveRight:
                if xPos in [2, 5, 8]:
                    return False
                else:
                    swap(self.position, xPos, 1)
                    return True
                
            elif action == Action.MoveUp:
                if xPos in [0, 1, 2]:
                    return False
                else:
                    swap(self.position, xPos, -3)
                    return True
                
            elif action == Action.MoveDown:
                if xPos in [6, 7, 8]:
                    return False
                else:
                    swap(self.position, xPos, 3)
                    return True
        
        def __repr__(self) -> str:
            n = 3
            board_list = [self.position[i:i + n] for i in range(0, len(self.position), n)]
            board = ""
            if self.action == Action.MoveLeft:
                board += "Action.MoveLeft"
                
            elif self.action == Action.MoveUp:
                board += "Action.MoveUp"
                
            elif self.action == Action.MoveRight:
                board += "Action.MoveRight"
            
            elif self.action == Action.MoveDown:
                board += "Action.MoveDown"
                
            else:
                board += "Action.NoAction"
            
            board += f"[ {self.f} ]\n"
            
            board2 = ""
            for row in board_list:
                for col in  row:
                    board2 += f"{col} "
                board2 += "\n"
            board2 = board2.replace("0", "_")
                
            return board + board2
        
        def __eq__(self, __o: object) -> bool:
            return self.position == __o.position
        
        def __lt__(self, __o) -> bool:
            return self.f < __o.f
        
        def __cmp__(self, __o) -> bool:
            return self.f < __o.f
        
        def computeHuristic(self):
            global goalPosition
            lst = [0 if self.position[i] == goalPosition[i] else 1 for i in range(9)]
            x =  sum(lst)
            self.h = x
        
        def computeG(self):
            
            currentNode, count = self, 0
            while currentNode.parent:
                count += 1
                currentNode = currentNode.parent
            
            self.g = count
            
        def computeF(self):
            self.computeHuristic()
            self.computeG()
            
            self.f = self.g + self.h
        
        def generateAllSuccessors(self):
            actions = [Action.MoveLeft, Action.MoveRight, Action.MoveUp, Action.MoveDown]
            # random.shuffle(actions)
            # random.shuffle(actions)
            
            successors = []
            for action in actions:
                node = Node(parent = self, action = action)
                isValidNode = node.move(action)
                
                if isValidNode :
                    node.computeF()
                    successors.append(node)
                    
            for s in successors:
                print(s)
                f.write(str(s) + "\n")
                
            return successors

        def getPath(self):
            currNode = self
            path = []
            while currNode.parent:
                path.append(currNode)
                currNode = currNode.parent
            path.append(currNode)
            return path
        
    initNode = Node(position = initPosition)
    goalNode = Node(position = goalPosition)

    class AStar:
        def __init__(self) -> None:
            self.OPEN = []
            self.CLOSED = []
        
        def popNode(self):
            self.OPEN.sort()
            return self.OPEN.pop(0)
        
        def solveEightPuzzle(self):
            global initNode
            
            self.OPEN.append(initNode)
            
            while self.OPEN:
                node = self.popNode()
                
                if node == goalNode:
                    print("Reached Goal\n")
                    f.write("Reached Goal\n")
                    
                    path = node.getPath()
                    path.reverse()
                    # path.append(node)
                    cost = len(path)
                    path = "\n   ^   \n".join([str(p) for p in path])
                    return path, cost, node
                
               
                
                self.CLOSED.append(node)
                
                successors = node.generateAllSuccessors()
                print("_____")
                f.write("___\n")
                
                if successors:
                    for s in successors:
                        if s not in self.OPEN:
                            if s in self.CLOSED :
                                i = self.CLOSED.index(s)
                                # If heuristic value of s > the heruistic value of the node in CLOSED list
                                # Add s to closed list
                                if s.f > self.CLOSED[i].f:
                                    self.CLOSED.append(s)
                               
                            else:
                                self.OPEN.append(s)
                                
                # if successors:
                #     for successor in successors:
                #         if successor in self.CLOSED:
                #             continue
                        
                #         elif successor in self.OPEN:
                #             i = self.OPEN.index(successor)
                #             node = self.OPEN[i]
                #             if successor.g > node.g:
                #                 continue
                            
                #         # elif (successor not in self.OPEN) and (successor not in self.CLOSED):
                #         self.OPEN.append(successor)
                        
            return None, None, None
    
    print("\nInit: ")
    f.write("\nInit: \n")
    print(initNode)
    f.write(str(initNode))
    
    print("\nGoal: ")
    f.write("\nGoal: \n")
    print(goalNode)
    f.write(str(goalNode))

    astar = AStar() 
    path, cost, finalNode = astar.solveEightPuzzle()
    if finalNode:
        
        
        # print("Final node:\n")
        # print(finalNode)
        print(":Path:\n",path)
        f.write(":Path:\n")
        f.write(path)
        print("Steps to goal: ", cost)
        f.write("\nSteps to goal: \n")
        f.write(str(cost))
        
        
    else:
        print("Unable to find solution.")
        f.write("Unable to find solution.")

print("Practical-6")

import random
import time
import numpy as np
import matplotlib.pyplot as plt

N=8
class Nqueen:
    def __init__(self):
        self.row = -1
        self.column = -1
        
    def __cmp__(self,other):
        return self.row==other.row and self.column==other.column
    
    def __eq__(self, other):
        return self.__cmp__(other)
    
    def __hash__(self):
        return hash(str([self.row,self.column]))
            
class Node:	
    
    def __init__(self, parent):
        self.Nqueen = [Nqueen() for i in range(N)]
        self.parent = parent

        if parent:
            self.moves = parent.moves + 1

            self.h = parent.h
            for i in range(N):
                self.Nqueen[i].row = parent.Nqueen[i].row
                self.Nqueen[i].column = parent.Nqueen[i].column
        else:
            self.moves = 0
            for i in range(N):
                row = random.randint(0, N - 1)
                self.placeQueen(row, i)
            self.h = self.generateHeuristic()

    def placeQueen(self, row, column):
        if row >= N or column >= N:
            return
        if self.Nqueen[column].row == row and self.Nqueen[column].column == column:
            return
        self.Nqueen[column].row = row
        self.Nqueen[column].column = column
        self.h = self.generateHeuristic()

   
    def generateHeuristic(self):
        count = 0
        for i in range(N):
            count = count + self.getConflictCount(self.Nqueen[i].row, self.Nqueen[i].column)
        return count

    def getConflictCount(self, row, column):
        count = 0
        for i in range(N):
            if not (self.Nqueen[i].row == row and self.Nqueen[i].column == column) and self.Nqueen[i].row == row:
                count += 1
            if not (self.Nqueen[i].row == row and self.Nqueen[i].column == column) and self.Nqueen[i].column == column:
                count += 1
            if not (self.Nqueen[i].row == row and self.Nqueen[i].column == column) and abs(
                    self.Nqueen[i].row - row) == abs(self.Nqueen[i].column - column):
                count += 1
        return count

    def __repr__(self):
        returnStr = ""
        for i in range(N):
            for j in range(N):
                if self.Nqueen[j].row == i:
                    returnStr = returnStr + "1 "
                else:
                    returnStr = returnStr + "0 "
            returnStr = returnStr + '\n'
        returnStr = returnStr + '\n'
        return returnStr
    def score(self):
        return self.h + self.moves

    def __cmp__(self, other):
        if other == None:
            return False
        return self.Nqueen == other.Nqueen

    def eq(self, other):
        return self.__cmp__(other)

    def __hash__(self):
        return hash(str(self.Nqueen))

    def __lt__(self, other):
        return self.score() < other.score()

    def nextAllStates(self):
        li = []
        row = self.moves
        for i in range(N):
            if not (self.Nqueen[i].row == row and self.Nqueen[i].column == i):
                nextNode = Node(self)
                nextNode.placeQueen(row, i)
                li.append(nextNode)
        return li

    def drawQueen(self):  
        chessboard = np.zeros((N, N),dtype=int)
        chessboard[1::2, 0::2] = 1 
        chessboard[0::2, 1::2] = 1
        plt.imshow(chessboard, cmap='binary')
        print("19012011022")
        for k in range(N):
            j = self.Nqueen[k].row
            i = self.Nqueen[k].column
            plt.text(i, j, 'Q', va='center', ha='center', color='black' if (i - j) % 2 == 0 else 'white', fontsize=30)
        plt.show()   
      
def a_star(initial_node):
    Open_list = []
    Close_list = []
    Open_list.append(initial_node)
    while len(Open_list) > 0:
        Open_list.sort()
        currentNode = Open_list.pop(0)
        Close_list.append(currentNode)
        if currentNode.h == 0:
            return currentNode
        all_successors = currentNode.nextAllStates()
        for i in all_successors:
            if i in Close_list:
                continue
            Open_list.append(i)

initialNode=Node(None)
#initialNode.drawQueen() 
start_time = time.time()
result =a_star(initialNode)
End_time = time.time()
result.drawQueen()
a=(End_time - start_time) * 1000
a=str(a)
a=a.split(".")
print("Execution time=", a[0], "ms")

"""Practical-7 """

from math import inf as infinity
from random import choice
import platform
import time
from os import system
HUMAN = -1
COMP = +1
board = [
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],]

def evaluate(state):
    if wins(state, COMP):
        score = +1
    elif wins(state, HUMAN):
        score = -1
    else:
        score = 0
    return score

def wins(state, player):

    win_state = [
        [state[0][0], state[0][1], state[0][2]],
        [state[1][0], state[1][1], state[1][2]],
        [state[2][0], state[2][1], state[2][2]],
        [state[0][0], state[1][0], state[2][0]],
        [state[0][1], state[1][1], state[2][1]],
        [state[0][2], state[1][2], state[2][2]],
        [state[0][0], state[1][1], state[2][2]],
        [state[2][0], state[1][1], state[0][2]],
    ]
    if [player, player, player] in win_state:
        return True
    else:
        return False

def game_over(state):
    return wins(state, HUMAN) or wins(state, COMP)

def empty_cells(state):
    cells = []
    for x, row in enumerate(state):
        for y, cell in enumerate(row):
            if cell == 0:
                cells.append([x, y])
    return cells

def valid_move(x, y):
    if [x, y] in empty_cells(board):
        return True
    else:
        return False

def set_move(x, y, player):
    if valid_move(x, y):
        board[x][y] = player
        return True
    else:
        return False

def minimax(state, depth, player):
    if player == COMP:
        best = [-1, -1, -infinity]
    else:
        best = [-1, -1, +infinity]
    if depth == 0 or game_over(state):
        score = evaluate(state)
        return [-1, -1, score]
    for cell in empty_cells(state):
        x, y = cell[0], cell[1]
        state[x][y] = player
        score = minimax(state, depth - 1, -player)
        state[x][y] = 0
        score[0], score[1] = x, y

        if player == COMP:
            if score[2] > best[2]:
                best = score  
        else:
            if score[2] < best[2]:
                best = score 
    return best

def clean():
    os_name = platform.system().lower()
    if 'windows' in os_name:
        system('cls')
    else:
        system('clear')
def render(state, c_choice, h_choice):
    chars = {
        -1: h_choice,
        +1: c_choice,
        0: ' '
    }
    str_line = '---------------'

    print('\n' + str_line)
    for row in state:
        for cell in row:
            symbol = chars[cell]
            print(f'| {symbol} |', end='')
        print('\n' + str_line)

def ai_turn(c_choice, h_choice):

    depth = len(empty_cells(board))
    if depth == 0 or game_over(board):
        return

    clean()
    print(f'Computer turn [{c_choice}]')
    render(board, c_choice, h_choice)

    if depth == 9:
        x = choice([0, 1, 2])
        y = choice([0, 1, 2])
    else:
        move = minimax(board, depth, COMP)
        x, y = move[0], move[1]

    set_move(x, y, COMP)
    time.sleep(1)

def human_turn(c_choice, h_choice):

    depth = len(empty_cells(board))
    if depth == 0 or game_over(board):
        return
    move = -1
    moves = {
        1: [0, 0], 2: [0, 1], 3: [0, 2],
        4: [1, 0], 5: [1, 1], 6: [1, 2],
        7: [2, 0], 8: [2, 1], 9: [2, 2],
    }
    clean()
    print(f'Human turn [{h_choice}]')
    render(board, c_choice, h_choice)
    while move < 1 or move > 9:
        try:
            move = int(input('Use numpad (1..9): '))
            coord = moves[move]
            can_move = set_move(coord[0], coord[1], HUMAN)

            if not can_move:
                print('Bad move')
                move = -1
        except (EOFError, KeyboardInterrupt):
            print('Close')
            exit()
        except (KeyError, ValueError):
            print('Bad choice')

def main():
    clean()
    h_choice = ''
    c_choice = ''  
    first = ''

    while h_choice != 'O' and h_choice != 'X':
        try:
            print('')
            h_choice = input('Choose X or O\nChosen: ').upper()
        except (EOFError, KeyboardInterrupt):
            print('Close')
            exit()
        except (KeyError, ValueError):
            print('Bad choice')

    if h_choice == 'X':
        c_choice = 'O'
    else:
        c_choice = 'X'

    clean()
    while first != 'Y' and first != 'N':
        try:
            first = input('First to start?[y/n]: ').upper()
        except (EOFError, KeyboardInterrupt):
            print('Close')
            exit()
        except (KeyError, ValueError):
            print('Bad choice')

    while len(empty_cells(board)) > 0 and not game_over(board):
        if first == 'N':
            ai_turn(c_choice, h_choice)
            first = ''
        human_turn(c_choice, h_choice)
        ai_turn(c_choice, h_choice)

    if wins(board, HUMAN):
        clean()
        print(f'Human turn [{h_choice}]')
        render(board, c_choice, h_choice)
        print('YOU WIN!')
    elif wins(board, COMP):
        clean()
        print(f'Computer turn [{c_choice}]')
        render(board, c_choice, h_choice)
        print('YOU LOSE!')
    else:
        clean()
        render(board, c_choice, h_choice)
        print('DRAW!')

    #exit()

if __name__ == '__main__':
    main()